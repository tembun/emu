#!/usr/local/bin/perl

#
# A simple implementation of email notifier.
# This programs utilizes two IMAP flags: ``UNSEEN'' and ``Flagged''
# (assuming you don't use "Flagged" flag for any purpose): the
# ``UNSEEN'' means message has not been seen by _you_ and 
# ``Flagged'' means it _has_ been seen by this program, thus it
# should _not_ notify about this message.  Otherwise, the program
# pops up a notification window.  It does not dispose received
# messages and basically it's supposed to be used with email
# client through which you will mark the letter read.
# To summarize: it searches ``UNSEEN'' messages, that are not marked
# as ``Flagged'', reads them in order to extract the address of a
# sender, then marks it ``UNSEEN'' back and sets the ``Flagged''
# for it so that it would not report about it later, if you wouldn't
# have read before the next time the daemon will check it, and
# finally it pops up a window (/usr/local/bin/xnf, by default)
# with information about mail sender.  It does it every 30 seconds,
# by default.
#
# The implementation of this is basically cut & paste from
# `emo' utility (which is a email obtainer) with some changes.
# Thus, the configuration file for this program (~/.emnrc) has
# the very same format as one for `emo'.  Though it omits the
# `mda' field, but adds the `notifier' which sets the program
# for sending notifications.  Please, consult the `emo' source
# code in order to get the information about `.emorc' config file.
#
# You can use `{FROM}' macro inside the `notifier' string in the
# config and it'll be substituted with sender's address.
#

use strict;
use Mail::IMAPClient;

my $imap;

my $HOME = $ENV{HOME};
my $config_path = "$HOME/.emnrc";

my %vars = (
	"HOME" => $HOME
);

my %config = (
	passfile => undef,
	serv => undef,
	login => undef,
	password => undef,
	notifier => "/usr/local/bin/xnf 'Email from {FROM}'",
	interval => 30
);


sub sub_vars {
	my ($line) = @_;
	if ($line =~ /\$(\w+)/) {
		my $var = $1;
		my $var_val = $vars{$var};
		$line =~ s/\$\w+/$var_val/g;
	}
	return $line;
}

# Parse main config file (~/.emnrc).
sub parse_config {
	my $is_config = open(CONFIG, "$config_path");
	if (!$is_config) {
		die "[emn]: a presence of a config file",
			"(~/.emnrc) is required.\n";
	}
	while (my $line = <CONFIG>) {
		# Lines started with "#" are commented and ignored.
		if ($line =~ /^#/) {
			next;
		}
		if ($line =~ /pass\s=>\s(.*)/) {
			$config{passfile} = sub_vars($1);
			next;
		}
		if ($line =~ /notifier\s=>\s(.*)/) {
			$config{notifier} = sub_vars($1);
		}
		if ($line =~ /interval\s=>\s(.*)/) {
			$config{interval} = sub_vars($1);
			next;
		}
	}
}

sub parse_passfile() {
	my $is_passfile = open(PASS, "$config{passfile}");
	if (!$is_passfile) {
		die "[emn]: can't open a passfile you specified:",
			"$config{passfile}.\n";
	}
	while (my $line = <PASS>) {
		#
		# For the sake of simplicity, we do _not_ support
		# commented lines here.  And I also suppose we don't
		# need variables here.
		#
		if ($line =~ /^serv\s(.*)/) {
			$config{serv} = "$1";
			next;
		}
		if ($line =~ /^login\s(.*)/) {
			$config{login} = "$1";
			next;
		}
		if ($line =~ /^password\s(.*)/) {
			$config{password} = "$1";
			next;
		}
	}
}

sub validate_config {
	if (not $config{serv}
		or not $config{login}
		or not $config{password}
	) {
		die "[emn]: either server, login or password are not",
		    "specified in the passfile ($config{passfile}).\n";
	}
}


parse_config();
parse_passfile();
validate_config();

#
# Try to connect until we succeed.
# This is helpful when there's no connection at program
# startup, but it makes it possible to bring the daemon
# to useful state when connection appears.
#
my $att = 0;
while (!$imap) {
	# Start sleeping only after first try we didn't succeed.
	if ($att++) {
		sleep 5;
	}
	$imap = Mail::IMAPClient->new(
		Server => $config{serv},
		User => $config{login},
		Password => $config{password},
		Ssl => 1,
		Uid => 0,
		IgnoreSizeErrors => 1
	)
}

# All the operations are performed on "INBOX" folder.
$imap->select("INBOX");

while (1) {
	#	
	# Handle connection time out.
	# Actually, this for some reasons don't work (`IsConnected'
	# method retunrs true event if we are not connected.  That's
	# why I added `or next' after the first command that we
	# do with an IMAP client so is it fails it won't go further
	# and will jump to the begining of loop.
	#
	while (!$imap->noop) {
		# Try to reconnect;
		$imap->reconnect;
		# Now check the result of our attempt.
		if ($imap->IsConnected()) {
			# We're connected.  Cool.
			last;
		}
		else {
			# Try again after a while.
			sleep 1;
		}
	}
	# Get all ``UNSEEN'' messages.
	my @unread = $imap->unseen or next;
	if (@unread) {
		my $total = $#unread + 1;
		for my $idx (0 .. $#unread) {
			my $msg_idx = $unread[$idx];
			#
			# If this unseen message is marked ``Flagged'',
			# it means we have already sent a notification
			# about it and we're not going to do this again.
			#
			my @flags = $imap->flags($msg_idx);
			if (grep(/^\\Flagged$/, @flags)) {
				next;
			}
			#
			# This action mark message as seen, but we'll
			# deny seeing later.
			#
			my $msg = $imap->message_string($msg_idx, 1);
			$msg =~ s/\r\n/\n/g;
			# Extract address of a sender.
			$msg =~ /^From: *(.*)/m;
			my $from_addr = $1;
			# Do _not_ modify the string inside `$config'.
			(my $ntf_cfg = $config{notifier}) =~ (
			    s/\{FROM\}/$from_addr/g
			);
			#
			# Mark message as ``UNSEEN'' back, so that our
			# email client can display it properly.
			#
			$imap->deny_seeing($msg_idx);
			#
			# Say that we've shown a notification for this
			# message.
			#
			$imap->set_flag("Flagged", $msg_idx);
			# Call a notifier.
			$from_addr and system $ntf_cfg;
		}
	}
	# Wait a while until next revision.
	sleep $config{interval};
}
